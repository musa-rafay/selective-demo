pipeline {
  agent any

  parameters {
    string(name: 'testbed_name', defaultValue: 'stest', description: 'Name of testbed')
    string(name: 'organization_name', defaultValue: 'rafay', description: 'Organization name')
    string(name: 'username', defaultValue: 'example@rafay.co', description: 'Username')

    // These URLs are autogenerated but exposed for visibility
    string(name: 'console_url', defaultValue: "console-${params.testbed_name}.dev.rafay-edge.net", description: 'Console URL')
    string(name: 'ops_console_url', defaultValue: "ops-console-${params.testbed_name}.dev.rafay-edge.net", description: 'Ops Console URL')
  }

  environment {
    CONSOLE_URL     = "console-${params.testbed_name}.dev.rafay-edge.net"
    OPS_CONSOLE_URL = "ops-console-${params.testbed_name}.dev.rafay-edge.net"
    REPO_URL = "https://github.com/RafaySystems/rafay-hub.git"
    GIT_CREDENTIALS = credentials('musa-rafay') 
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Compute/echo params') {
      steps {
        script {
          echo "testbed_name      = ${params.testbed_name}"
          echo "organization_name = ${params.organization_name}"
          echo "username          = ${params.username}"
          echo "console_url       = ${env.CONSOLE_URL}"
          echo "ops_console_url   = ${env.OPS_CONSOLE_URL}"
        }
      }
    }

    stage('Fetch and Filter Branches') {
      steps {
        script {
          // Extract credentials
          def gitUser = GIT_CREDENTIALS.username
          def gitToken = GIT_CREDENTIALS.password

          // Build auth URL
          def authURL = REPO_URL.replace("https://", "https://${gitUser}:${gitToken}@")

          // Print for debugging
          echo "üîç Authenticated URL: ${authURL}"

          // Fetch branches and filter
          sh """
            echo " Fetching branches from GitHub..."
            git ls-remote --heads ${authURL} | awk '{print $2}' | sed 's#refs/heads/##' > all_branches.txt

            echo "Filtering only main, dev, or vX.Y.x branches..."
            grep -E '^(main|dev|v[0-9]+\.[0-9]+\.x)$' all_branches.txt > filtered_branches.txt

            echo "Filtered branches:"
            cat filtered_branches.txt
          """
        }
      }

    stage('Build Filtered Branches') {
      steps {
        script {
          def branches = readFile('filtered_branches.txt').split('\n')
          echo "Will build the following branches: ${branches.join(', ')}"

          // Simulate builds for each (real build logic can go here)
          for (branch in branches) {
            echo " Building branch: ${branch}"
            // add real build steps here if needed
          }
        }
      }

    
    stage('Detect changes') {
      steps {
        script {
          sh 'git fetch --no-tags origin main --quiet'
          def base = sh(returnStdout: true, script: 'git merge-base origin/main HEAD').trim()
          def changed = sh(returnStdout: true,
            script: "git diff --name-only ${base} HEAD"
          ).trim().split('\n')

          echo "Changed files:"
          changed.each { echo "- ${it}" }
        }
      }
    }

    stage('SSH to VM (noop)') {
      steps {
        sshagent(['testbed-vm-ssh']) {
          sh 'ssh -o StrictHostKeyChecking=no ubuntu@144.24.6.170 "echo hello from remote"'
        }
      }
    }
  }

  post {
    failure {
      echo '‚ùå Pipeline failed.'
    }
    success {
      echo '‚úÖ Pipeline succeeded.'
    }
  }
}
